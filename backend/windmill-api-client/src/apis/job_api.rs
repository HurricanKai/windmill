/*
 * Windmill server API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.39.0
 * Contact: contact@windmill.dev
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`cancel_queued_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelQueuedJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_suspended_job_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSuspendedJobGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_suspended_job_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSuspendedJobPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_job_signature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateJobSignatureError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_completed_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCompletedJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_completed_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCompletedJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_job_updates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJobUpdatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_completed_jobs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCompletedJobsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_jobs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListJobsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_queue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resume_suspended_job_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResumeSuspendedJobGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resume_suspended_job_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResumeSuspendedJobPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_flow_by_path`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunFlowByPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_flow_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunFlowPreviewError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_script_by_hash`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunScriptByHashError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_script_by_path`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunScriptByPathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_script_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunScriptPreviewError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_wait_result_script_by_path`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunWaitResultScriptByPathError {
    UnknownValue(serde_json::Value),
}


pub async fn cancel_queued_job(configuration: &configuration::Configuration, workspace: &str, id: &str, cancel_queued_job_request: crate::models::CancelQueuedJobRequest) -> Result<String, Error<CancelQueuedJobError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/queue/cancel/{id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_queued_job_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CancelQueuedJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn cancel_suspended_job_get(configuration: &configuration::Configuration, workspace: &str, id: &str, resume_id: i32, signature: &str, payload: Option<serde_json::Value>) -> Result<String, Error<CancelSuspendedJobGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/cancel/{id}/{resume_id}/{signature}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id), resume_id=resume_id, signature=crate::apis::urlencode(signature));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = payload {
        local_var_req_builder = local_var_req_builder.query(&[("payload", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CancelSuspendedJobGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn cancel_suspended_job_post(configuration: &configuration::Configuration, workspace: &str, id: &str, resume_id: i32, signature: &str, body: Option<serde_json::Value>) -> Result<String, Error<CancelSuspendedJobPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/cancel/{id}/{resume_id}/{signature}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id), resume_id=resume_id, signature=crate::apis::urlencode(signature));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CancelSuspendedJobPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_job_signature(configuration: &configuration::Configuration, workspace: &str, id: &str, resume_id: i32) -> Result<String, Error<CreateJobSignatureError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/job_signature/{id}/{resume_id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id), resume_id=resume_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateJobSignatureError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_completed_job(configuration: &configuration::Configuration, workspace: &str, id: &str) -> Result<crate::models::CompletedJob, Error<DeleteCompletedJobError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/completed/delete/{id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteCompletedJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_completed_job(configuration: &configuration::Configuration, workspace: &str, id: &str) -> Result<crate::models::CompletedJob, Error<GetCompletedJobError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/completed/get/{id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCompletedJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_job(configuration: &configuration::Configuration, workspace: &str, id: &str) -> Result<crate::models::Job, Error<GetJobError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/get/{id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_job_updates(configuration: &configuration::Configuration, workspace: &str, id: &str, running: Option<bool>, log_offset: Option<i32>) -> Result<crate::models::GetJobUpdates200Response, Error<GetJobUpdatesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/getupdate/{id}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = running {
        local_var_req_builder = local_var_req_builder.query(&[("running", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_offset {
        local_var_req_builder = local_var_req_builder.query(&[("log_offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetJobUpdatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_completed_jobs(configuration: &configuration::Configuration, workspace: &str, order_desc: Option<bool>, created_by: Option<&str>, parent_job: Option<&str>, script_path_exact: Option<&str>, script_path_start: Option<&str>, script_hash: Option<&str>, created_before: Option<String>, created_after: Option<String>, success: Option<bool>, job_kinds: Option<&str>, is_skipped: Option<bool>, is_flow_step: Option<bool>) -> Result<Vec<crate::models::CompletedJob>, Error<ListCompletedJobsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/completed/list", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order_desc {
        local_var_req_builder = local_var_req_builder.query(&[("order_desc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_by {
        local_var_req_builder = local_var_req_builder.query(&[("created_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_exact {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_exact", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_start {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_hash {
        local_var_req_builder = local_var_req_builder.query(&[("script_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_before {
        local_var_req_builder = local_var_req_builder.query(&[("created_before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_after {
        local_var_req_builder = local_var_req_builder.query(&[("created_after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = success {
        local_var_req_builder = local_var_req_builder.query(&[("success", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_kinds {
        local_var_req_builder = local_var_req_builder.query(&[("job_kinds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_skipped {
        local_var_req_builder = local_var_req_builder.query(&[("is_skipped", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_flow_step {
        local_var_req_builder = local_var_req_builder.query(&[("is_flow_step", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListCompletedJobsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_jobs(configuration: &configuration::Configuration, workspace: &str, created_by: Option<&str>, parent_job: Option<&str>, script_path_exact: Option<&str>, script_path_start: Option<&str>, script_hash: Option<&str>, created_before: Option<String>, created_after: Option<String>, job_kinds: Option<&str>, is_skipped: Option<bool>, is_flow_step: Option<bool>, success: Option<bool>) -> Result<Vec<crate::models::Job>, Error<ListJobsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/list", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = created_by {
        local_var_req_builder = local_var_req_builder.query(&[("created_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_exact {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_exact", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_start {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_hash {
        local_var_req_builder = local_var_req_builder.query(&[("script_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_before {
        local_var_req_builder = local_var_req_builder.query(&[("created_before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_after {
        local_var_req_builder = local_var_req_builder.query(&[("created_after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_kinds {
        local_var_req_builder = local_var_req_builder.query(&[("job_kinds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_skipped {
        local_var_req_builder = local_var_req_builder.query(&[("is_skipped", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_flow_step {
        local_var_req_builder = local_var_req_builder.query(&[("is_flow_step", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = success {
        local_var_req_builder = local_var_req_builder.query(&[("success", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListJobsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_queue(configuration: &configuration::Configuration, workspace: &str, order_desc: Option<bool>, created_by: Option<&str>, parent_job: Option<&str>, script_path_exact: Option<&str>, script_path_start: Option<&str>, script_hash: Option<&str>, created_before: Option<String>, created_after: Option<String>, success: Option<bool>, job_kinds: Option<&str>) -> Result<Vec<crate::models::QueuedJob>, Error<ListQueueError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/queue/list", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order_desc {
        local_var_req_builder = local_var_req_builder.query(&[("order_desc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_by {
        local_var_req_builder = local_var_req_builder.query(&[("created_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_exact {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_exact", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_path_start {
        local_var_req_builder = local_var_req_builder.query(&[("script_path_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = script_hash {
        local_var_req_builder = local_var_req_builder.query(&[("script_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_before {
        local_var_req_builder = local_var_req_builder.query(&[("created_before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_after {
        local_var_req_builder = local_var_req_builder.query(&[("created_after", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = success {
        local_var_req_builder = local_var_req_builder.query(&[("success", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_kinds {
        local_var_req_builder = local_var_req_builder.query(&[("job_kinds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn resume_suspended_job_get(configuration: &configuration::Configuration, workspace: &str, id: &str, resume_id: i32, signature: &str, payload: Option<serde_json::Value>) -> Result<String, Error<ResumeSuspendedJobGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/resume/{id}/{resume_id}/{signature}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id), resume_id=resume_id, signature=crate::apis::urlencode(signature));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = payload {
        local_var_req_builder = local_var_req_builder.query(&[("payload", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResumeSuspendedJobGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn resume_suspended_job_post(configuration: &configuration::Configuration, workspace: &str, id: &str, resume_id: i32, signature: &str, body: Option<serde_json::Value>) -> Result<String, Error<ResumeSuspendedJobPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/resume/{id}/{resume_id}/{signature}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), id=crate::apis::urlencode(id), resume_id=resume_id, signature=crate::apis::urlencode(signature));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResumeSuspendedJobPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_flow_by_path(configuration: &configuration::Configuration, workspace: &str, path: &str, request_body: ::std::collections::HashMap<String, serde_json::Value>, scheduled_for: Option<String>, scheduled_in_secs: Option<i32>, parent_job: Option<&str>) -> Result<uuid::Uuid, Error<RunFlowByPathError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run/f/{path}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scheduled_for {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_for", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scheduled_in_secs {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_in_secs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunFlowByPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_flow_preview(configuration: &configuration::Configuration, workspace: &str, flow_preview: crate::models::FlowPreview) -> Result<uuid::Uuid, Error<RunFlowPreviewError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run/preview_flow", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&flow_preview);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunFlowPreviewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_script_by_hash(configuration: &configuration::Configuration, workspace: &str, hash: &str, body: serde_json::Value, scheduled_for: Option<String>, scheduled_in_secs: Option<i32>, parent_job: Option<&str>) -> Result<uuid::Uuid, Error<RunScriptByHashError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run/h/{hash}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), hash=crate::apis::urlencode(hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scheduled_for {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_for", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scheduled_in_secs {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_in_secs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunScriptByHashError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_script_by_path(configuration: &configuration::Configuration, workspace: &str, path: &str, request_body: ::std::collections::HashMap<String, serde_json::Value>, scheduled_for: Option<String>, scheduled_in_secs: Option<i32>, parent_job: Option<&str>) -> Result<uuid::Uuid, Error<RunScriptByPathError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run/p/{path}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scheduled_for {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_for", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scheduled_in_secs {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_in_secs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunScriptByPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_script_preview(configuration: &configuration::Configuration, workspace: &str, preview: crate::models::Preview) -> Result<uuid::Uuid, Error<RunScriptPreviewError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run/preview", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&preview);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunScriptPreviewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn run_wait_result_script_by_path(configuration: &configuration::Configuration, workspace: &str, path: &str, request_body: ::std::collections::HashMap<String, serde_json::Value>, scheduled_for: Option<String>, scheduled_in_secs: Option<i32>, parent_job: Option<&str>) -> Result<serde_json::Value, Error<RunWaitResultScriptByPathError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/w/{workspace}/jobs/run_wait_result/p/{path}", local_var_configuration.base_path, workspace=crate::apis::urlencode(workspace), path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scheduled_for {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_for", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scheduled_in_secs {
        local_var_req_builder = local_var_req_builder.query(&[("scheduled_in_secs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_job {
        local_var_req_builder = local_var_req_builder.query(&[("parent_job", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunWaitResultScriptByPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

